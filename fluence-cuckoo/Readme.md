# Cuckoo For Coca Puffs

In this tutorial we expose a Rust [cuckoofilter](https://crates.io/crates/cuckoofilter) crate as a Fluence service, deploy it to the Fluence network and use that service in a stylized frontend Rust app.

## Cuckoo Filters
The [Cuckoo filter](https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf) is a probabilistic data structure just like [bloom filters](https://en.wikipedia.org/wiki/Bloom_filter) but better; better, because we can not just add but also delete keys from the filter. How 'bout that. Quick note on membership tests, bloom filters and probabilities: A bloom, and cuckoo, filter definitively indicate set exclusion, e.g., item is not in filter, and probabilistically indicate set inclusion. For an awesome overview and interactive tutorial, checkout [Bloom Filters By Example](https://llimllib.github.io/bloomfilter-tutorial/).

Most Ethereum developers are familiar with bloom filters as every time a block is forged, the address of every logging contract and associated indexed fields from the logs generated by the executed transactions are added to a bloom filter, which is added to the block header. See the [Yellow paper](https://ethereum.github.io/yellowpaper/paper.pdf) for more info.


## Cuckoo Filters as Fluence Services
Aside from the fact that cuckoo filters (CF) may be part of your distributed workflow and a service implementation comes in more than handy, there is another reason why a CF as a Service is useful: CF implementations tend to not follow a particular implementation standard and consequently are implementation specific. This makes makes sharing or re-using of filters challenging. CF as Service greatly alleviates these issues.

## Getting Started
We are assuming that you have had the opportunity to work through the Fluence [documentation](https://fluence.dev/) and have it handy as a reference when necessary.

Rather than code our own cuckoo filter, we use the awesome [cuckoofilter](https://crates.io/crates/cuckoofilter) crate as our starting point and write the wrapper functions in our [main.rs](./fce-cuckoo/src/main.rs). This turns out to be a pretty straight forward process and crate functionality nicely maps into our Fluence module except for some type limitations in the exposed function, i.e. `#[fce]` functions. 

Rust is strongly typed, which is reflected in its [hashing](https://doc.rust-lang.org/std/hash/index.html), and that doesn't fully map into our module. For example, H(5_u32) != H(5_64) whereas the respective byte arrays and associated hashes are. Due to the lack of generics in WASI, we lose some of the fine-grained discrimination available in the native crate. However, this is a small price to pay for interoperability gains made.

Now that we have our module in place, we compile our code into a wasm module with Fluence `fce` command line tool and use `build.sh` to do so. If you haven't installed fce, or it's been a while:

```bash
cargo +nightly install fcli --force
```

and proceed to run the `build` script:

```bash
./build.sh
```

Let's unpack the script:

```bash
#!/bin/sh
mkdir -p artifacts

cd fce-cuckoo
cargo update
fce build --release
cd ..

rm -f artifacts/*
cp fce-cuckoo/target/wasm32-wasi/release/fce-cuckoo.wasm artifacts/
```
First, we create a new dir, `artifacts`, that serves as a convenience parking lot for our wasm modules. We then execute the typical `cargo update` followed by the `fce build --release`. The fce cli closely follows cargo and we just build the wasm module with the release flag. Finally, we copy the wasm module from the deep recesses of the compiler target directory tree to the much more convenient `artifacts` directory.

Before we proceed, we need to create a [service configuration](https://fluence.dev/docs/service-config-reference). That is, we need to specify a few attributes defining our service. This is done in the [Config.tom](./fce-cuckoo/Config.tom) file. For our purposes, we have simple specification attributes limited to name and logging. See the reference for more advanced configurations.

Now that we got our cuckoo filter wasm module and service configuration, we can explore and test our masterpiece locally using the Fluence FCE repl. In the `fce-cuckoo` dir, fire up the repl with `fce-repl Config.toml` which gets us to the command line:

```bash
Welcome to the FCE REPL (version 0.1.33)
app service was created with service id = 80580519-9da6-477c-8265-0eb27d1f89cc
elapsed time 166.494711ms

1>
```

The first ting to o is check that all our (external) interfaces are available:

```bash
1> interface
Loaded modules interface:

fce-cuckoo:
  fn create_and_add_cf(data: Array<Array<U8>>) -> String
  fn is_empty(cf: String) -> I32
  fn memory_usage(cf: String) -> U64
  fn service_info() -> String
  fn delete(cf: String, items: Array<Array<U8>>) -> Array<I32>
  fn create_cf(with_capacity: U32) -> String
  fn contains(cf: String, items: Array<Array<U8>>) -> Array<I32>
  fn len(cf: String) -> U64
  fn add(data: Array<Array<U8>>) -> String
```

Looks like we're all good to go and we can now run each of those functions with the appropriate signature parameters using the <command, module name, function name, function parameter> syntax. For example, 

```bash
2> call fce-cuckoo service_info []
result: String("{\"name\":\"Cuckoo Filter\",\"package\":\"https://crates.io/crates/cuckoofilter\",\"source\":\"https://github.com/axiomhq/rust-cuckoofilter\",\"version\":\"0.5.0\"}")
 elapsed time: 158.616µs
```

We can also explore each functions environment variables wit the `envs` command:

```3> envs fce-cuckoo service_info
Environment variables:
tmp=/var/folders/yq/fvkl2sbd14sc4_kt00pqk76r0000gn/T/80580519-9da6-477c-8265-0eb27d1f89cc/tmp
local=/var/folders/yq/fvkl2sbd14sc4_kt00pqk76r0000gn/T/80580519-9da6-477c-8265-0eb27d1f89cc/local
service_id=80580519-9da6-477c-8265-0eb27d1f89cc
```

Simply type `help` on the repl command line to see all features available.

## From Local Module To Deployed Service
For our purposes, we just want fce-cuckoo to be a granular service and it's time to deploy it to the network. In order to manage the distribution process, we need the Fluence `fldist` tool. If you have not installed it:

```bash
```

```bash
mbp16~/localdev/lw3d/fluence-cuckoo/fce-cuckoo(cuckoo|✚5…) % fldist upload -n fce-cuckoo --p artifacts/fce-cuckoo.wasm
client seed: 7HqYvGqsrmnT49ckmGLRHbipP3Nt1Bap6gNo88weqW95
client peerId: 12D3KooWD6LXHJSsBSehFoJGoLv6KZTM1XhRnNcMf3osAgtfQjca
node peerId: 12D3KooWBUJifCTgaxAUrcM9JysqCcS4CS8tiYH5hExbdWCAoNwb
uploading module fce-cuckoo to node 12D3KooWBUJifCTgaxAUrcM9JysqCcS4CS8tiYH5hExbdWCAoNwb via client 12D3KooWD6LXHJSsBSehFoJGoLv6KZTM1XhRnNcMf3osAgtfQjca with config:
{
  "name": "fce-cuckoo",
  "mem_pages_count": 100,
  "logger_enabled": true,
  "wasi": {
    "preopened_files": []
  }
}
```

We now have uploaded our wasm module to the Fluence testnet network. The next step is to create and upload a blueprint:

```
mbp16~/localdev/lw3d/fluence-cuckoo/fce-cuckoo(cuckoo|✚5…) % fldist add_blueprint -i 1343D0B4-84C5-496A-A520-77E2DD0B9316 -d fce-cuckoo.wasm -n fce-cuckoo  -s 7HqYvGqsrmnT49ckmGLRHbipP3Nt1Bap6gNo88weqW95
client seed: 7HqYvGqsrmnT49ckmGLRHbipP3Nt1Bap6gNo88weqW95
client peerId: 12D3KooWD6LXHJSsBSehFoJGoLv6KZTM1XhRnNcMf3osAgtfQjca
node peerId: 12D3KooWBUJifCTgaxAUrcM9JysqCcS4CS8tiYH5hExbdWCAoNwb
uploading blueprint fce-cuckoo to node 12D3KooWBUJifCTgaxAUrcM9JysqCcS4CS8tiYH5hExbdWCAoNwb via client 12D3KooWD6LXHJSsBSehFoJGoLv6KZTM1XhRnNcMf3osAgtfQjca
blueprint '1343D0B4-84C5-496A-A520-77E2DD0B9316' added successfully

```

now we create a service:

```

mbp16~/localdev/lw3d/fluence-cuckoo/fce-cuckoo(cuckoo|✚5…) % fldist create_service  -i 1343D0B4-84C5-496A-A520-77E2DD0B9316  -s 7HqYvGqsrmnT49ckmGLRHbipP3Nt1Bap6gNo88weqW95
client seed: 7HqYvGqsrmnT49ckmGLRHbipP3Nt1Bap6gNo88weqW95
client peerId: 12D3KooWD6LXHJSsBSehFoJGoLv6KZTM1XhRnNcMf3osAgtfQjca
node peerId: 12D3KooWBUJifCTgaxAUrcM9JysqCcS4CS8tiYH5hExbdWCAoNwb
creating service 1343D0B4-84C5-496A-A520-77E2DD0B9316
fldist create_service

Create a service from existing blueprint

Options:
      --help     Show help                                             [boolean]
      --version  Show version number                                   [boolean]
  -s, --seed     Client seed                                            [string]
  -i, --id       blueprint id                                [string] [required]

Error: callback for _callback/createService timed out after 20000
    at Timeout._onTimeout (/Users/bebo/.nvm/versions/node/v12.16.3/lib/node_modules/@fluencelabs/fldist/node_modules/@fluencelabs/fluence/dist/api.js:169:28)
    at listOnTimeout (internal/timers.js:549:17)
    at processTimers (internal/timers.js:492:7)
mbp16~/localdev/lw3d/fluence-cuckoo/fce-cuckoo(cuckoo|✚5…) %

```

and now we can use the service even from the command line with the `fldist` tool. But first we need to write a AIR script, see `air.clj`. 

```bash
mbp16~/localdev/lw3d/fluence-cuckoo/fce-cuckoo(cuckoo|✚5…) % fldist run_air -p air.clj -d '{"service": "1343D0B4-84C5-496A-A520-77E2DD0B9316"}'
client seed: 9HcZcmB3UPv6c1rc59u7CNyMAfQKVwxTWYFuQhBhTk28
client peerId: 12D3KooWS2e5tdd1AKJshcZGS4Jw8HHPjWkYrASphfvGpgdf8o7q
node peerId: 12D3KooWBUJifCTgaxAUrcM9JysqCcS4CS8tiYH5hExbdWCAoNwb
Particle id: d2b9c39b-ee72-4213-a785-5719121e2ba3. Waiting for results... Press Ctrl+C to stop the script.
^C
```
