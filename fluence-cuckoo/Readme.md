# Cuckoo For Coca Puffs

In this tutorial we expose a Rust [cuckoofilter](https://crates.io/crates/cuckoofilter) crate as a Fluence service, deploy it to the Fluence test network and use that service in a frontend Rust app.

## Cuckoo Filters
The [Cuckoo filter](https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf) is a probabilistic data structure just like [bloom filters](https://en.wikipedia.org/wiki/Bloom_filter) but better; better, because we can not just add but also delete keys from the filter. How 'bout that. Most Ethereum developers are familiar with bloom filters as every time a block is forged, the address of every logging contract and associated indexed fields from the logs generated by the executed transactions are added to a bloom filter, which is added to the block header. See the [Yellow](https://ethereum.github.io/yellowpaper/paper.pdf) paper for more info.


## Cuckoo Filters as Fluence Services
Aside from the fact that cuckoo filters (CF) may be part of your distributed workflow and a service implementation comes in more than handy, there is another reason why a CF as a Service is useful: CF implementations tend to not follow one particular standard and consequently are implementation specific. This makes makes the sharing or re-using of filters challenging. A (permanently) available CF as Service greatly alleviates these issues.

## Getting Started
note: Rust is strongly typed and that is reflected in its [hashing](https://doc.rust-lang.org/std/hash/index.html). For example, H(5_u32) != H(5_64) whereas the respective byte arrays and associated hashes are. Due to the lack of generics in WASI, we lose some of the fine-grained discrimination available in the native crate. However, this is a small price to pay for interoperability gains made.